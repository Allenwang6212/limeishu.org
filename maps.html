
<!DOCTYPE html>
<html>
<head>
<title>桃源聲音地圖</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="initial-scale=1.0, user-scalable=no" />
<meta name="keywords" content="sound, map, soundmap, sound map, field recording, art, sound art, net art, locative media, mobile, sense of place, cartography, map, mapping, soundwalk, sound walk, acoustic ecology, soundscape, listening">
<meta name="description" content="radio aporee ::: maps is a global soundmap dedicated to field recording, phonography and the art of listening." />
<base href="http://aporee.org/maps/work/" />
<link href="css/page.css" media="screen" rel="stylesheet" type="text/css" />
<link href="css/dropdown.css" media="screen" rel="stylesheet" type="text/css" />
<link href="css/menu.css" media="screen" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="http://maps.google.com/maps/api/js?v=3&sensor=false"></script>
<script type="text/javascript" src="http://aporee.org/maps/work/js/json2.stringify.js"></script>
<script type="text/javascript" src="http://aporee.org/maps/work/js/json_stringify.js"></script>
<script type="text/javascript" src="http://aporee.org/maps/work/js/sajax.js"></script>
<script type="text/javascript" src="http://aporee.org/maps/work/js/markerclusterer_packed.js"></script>
<script type="text/javascript" src="http://aporee.org/maps/work/js/OverlayMessage.js"></script>
<script type="text/javascript" src="http://aporee.org/maps/work/js/ejs_production.js"></script>
<script type="text/javascript" src="http://aporee.org/maps/work/js/keydragzoom_packed.js"></script>
<script type='text/javascript' src="http://aporee.org/maps/work/js/en.js"></script>
<script type='text/javascript' src='http://aporee.org/mediaplayer/xx/jwplayer.js'></script>
<script type="text/javascript">
	sajax_debug_mode = false;
	sajax_failure_redirect = "http://aporee.org/aporee.html";
	function x_change() {
		return sajax_do_call("change", arguments, "GET", true, "");
	}
// for older browser not having indexOf
if (!Array.prototype.indexOf) {
	Array.prototype.indexOf = function(elt /*, from*/){
		var len = this.length;
		var from = Number(arguments[1]) || 0;
		from = (from < 0)
				 ? Math.ceil(from)
				 : Math.floor(from);
		if (from < 0)
			from += len;
		for (; from < len; from++) {
			if (from in this &&
					this[from] === elt)
				return from;
		}
		return -1;
	};
}
/*** main project url GLOBAL ...***/
var projectUrl = 'http://aporee.org/maps/work/';		// /maps/work/
var projectAlias = 'http://aporee.org/maps/';	// /maps/
/*** aporee maps related functions ***/
var Aporee = {
	/* always process query_string */
	query: (function(a) {
			if (a == "") return {};
			var b = {};
			for (var i = 0; i < a.length; ++i) {
				// p: array key, val, e.g. loc, nnn
				var p=a[i].split('=');
				if (p.length != 2) continue;
				b[p[0]] = decodeURIComponent(p[1].replace(/\+/g, " "));
			}
			return b;
		})(window.location.search.substr(1).split('&')),


	locationsList: null,	// temp results for searches, playlists etc.
	om: null,		// reusable overlay for entertainment
	/*** little helpers ***/
	Utils: {
		toggle: function(id) {
			var e = document.getElementById(id);
			if(e.style.display == 'block') {
				e.style.display = 'none';
			} else {
				e.style.display = 'block';
			}
		}
	},
	/*** Mediaplayer ***/
	Player: {
		player: [],	// registered player ids
		playlist: [],	// filled by loadPlaylist
		setOnComplete: function() { alert('sound completed!') },
		create: function(id){
			// console.log("player created");
			var self = this;
			jwplayer(id).setup({
				'flashplayer':	'/mediaplayer/xx/player.swf',
				'width':	400,
				'height':	24,
				'backcolor':	'000000',
				'frontcolor':	'a0a0a0',
				'lightcolor':	'f0f0f0',
				'autostart':	'false',
				'controlbar':	'bottom',
				'dock':		'false',
				'repeat':	'list',
				'volume':	'80',
				'events':	{
					'onPlaylistItem': self.updateSoundInfo
					/* 'onComplete': Player.setOnComplete */
				}
			});
			// register player id
			this.player.push(id);
		},
		/*** update info div with sound info ***/
		updateSoundInfo: function(e) {
			var curItem = this.getPlaylistItem(e.index);
			var items = this.getPlaylist().length;
			var idx = curItem.idx
			var locid = parseInt(curItem.locid);	// type!
			var sndid = parseInt(curItem.sndid);	// type!
			var ctitle = curItem.ctitle ? curItem.ctitle : '';
			var ltitle = curItem.ltitle ? curItem.ltitle : '';
			var artist = curItem.artist ? curItem.artist : '';
			var uid = curItem.uid;
			var recdate = curItem.recdate ? curItem.recdate : '';
			var data = {
				id: idx,
				items: items,	// # of playlist items
				locid: locid,
				sndid: sndid,
				ltitle: ltitle,
				ctitle: ctitle,
				artist: artist,
				uid: uid,
				recdate: recdate,
				details: Strings.details,
			};
			// console.log(data);
			// EJS.config({ cache: false });
			new EJS({ url: 'templ/soundInfo.ejs' }).update('info', data)
			Aporee.Map.panTo(locid);	// jump to loc
		},
		/*** get playlist for a 2D array of locids: idx, sndid, locid, title, file, duration, artists, uid, recdate
			input format: array(locid, array(sndid1, ..., sndidn)),
		***/
		loadPlaylist: function (locids) {
			var self = this;
			var data = {};
			data.args = [ locids ];
			data.func_name = 'getPlaylist';
			try {
				x_change(data, function(result) {

					self.playlist = result.ret;
					// console.log(playlist);
					jwplayer().load(self.playlist);
					jwplayer().play();
					// clear overlay if any
					if(Aporee.om) Aporee.om.Clear();
				});
			} catch (e) {
				alert(e.message);
			}
		},
		/*** load specific item from playlist, idx ***/
		loadItem: function(item) {
			// need to have better reference to player?
			jwplayer().playlistItem(item);
		},
		/*** show playlist in text div, how to prevent async problem?  ***/
		showPlaylist: function() {
			if(this.playlist && this.playlist.length > 0) {
				// EJS.config({ cache: false });
				new EJS({ url: 'templ/playlist.ejs' }).update('text', { playlist: this.playlist });
			} else {
				document.getElementById('text').innerHTML = 'no items in playlist.';
			}
		},
		/*** play currently visible markers ***/
		playVisible: function() {
			Aporee.om = new OverlayMessage( document.getElementById( 'map' ) );
			Aporee.om.Set( 'loading visible places...' );
			var bounds = Aporee.Map.map.getBounds();
			var l = Aporee.Map.markersArray.length;
			var locids = [];
			var visible = 0;
			for(var i=0; i<l; i++) {
 				if(bounds.contains(Aporee.Map.markersArray[i].getPosition())) {
					// Aporee.Map.markersArray[i].getVisible(): 	true also for markers hidden in cluster
					// Aporee.Map.markersArray[i].getMap(): 	true only for markers not in cluster
					locids.push(Aporee.Map.markersArray[i].locid);
					visible++;
					if(visible > 100) break;	// limit 100
				}
			}
			// load playlists or clear om
			if(visible) {
				this.loadPlaylist(locids);
				// this.showPlaylist();	// doesn't work, async playlist fill!
			} else {
				Aporee.om.Clear();
			}
		},
		/*** play random selection ***/
		playRandom: function() {
			Aporee.om = new OverlayMessage( document.getElementById( 'map' ) );
			Aporee.om.Set( 'loading random places...' );
			var data = {};
			var locids = [];
			for(var i=0; i<50; i++) {	// limit 100
				var idx = Math.round(Math.random() * Aporee.Map.markersIndexArray.length);
				locids.push(Aporee.Map.markersIndexArray[idx]);
			}
			this.loadPlaylist(locids);	// this should clear OM
			// this.showPlaylist();
			// Aporee.om.Clear();
		}
	},
	/*** the google map ***/
	Map: {
		map: null,
		inputMarker: null,
		hotMarker: null,
		markerCluster: null,
		dragZoomObj: null,
		dragStart: null,	// point, set by drag listener
		dragStop: null,
		locationsArray: [],	// ajax result, array of objects
		markersArray: [],	// [idx, marker]
		markersIndexArray: [],	// [idx, locid]
		geocoder: null,
		infoWindow: new google.maps.InfoWindow({
			pixelOffset: new google.maps.Size(0,15),
			zIndex: 100
			// maxWidth: 500
		}),
		osmMapType: new google.maps.ImageMapType({
			getTileUrl: function(coord, zoom) {
				return "http://tile.openstreetmap.org/" +
				zoom + "/" + coord.x + "/" + coord.y + ".png";
			},
			tileSize: new google.maps.Size(256, 256),
			isPng: true,
			alt: "Open Street Map Layer",
			name: "OpenStreetMap",
			maxZoom: 18,	// ??? no effect
			// opacity: 0.5
		}),
		Settings: {
			defaultPoint: new google.maps.LatLng(52.49327,13.42433),
			// defaultPoint: new google.maps.LatLng(0,0),
			defaultZoom: 3,
			inputMarkerImg: new google.maps.MarkerImage(
				'images/input.gif',
				new google.maps.Size(30,30),	// img size
				new google.maps.Point(0,0), 	//
				new google.maps.Point(15,15)	// anchor mitte
			),
			mapsMarkerImg: new google.maps.MarkerImage(
				'images/default.png',
				new google.maps.Size(30,30),
				new google.maps.Point(0,0),
				new google.maps.Point(15,15)
			),
			mapsActiveMarkerImg: new google.maps.MarkerImage(
				'images/hot.gif',
				new google.maps.Size(30,30),
				new google.maps.Point(0,0),
				new google.maps.Point(15,15)
			),
			clusterStyles: [
				{ url: 'images/cluster50.png', width: 50, height: 50, anchor: [25, 0], textColor: '#A0A0A0', textSize: 10 },
				{ url: 'images/cluster60.png', width: 60, height: 60, anchor: [30, 0], textColor: '#A0A0A0', textSize: 10 },
				{ url: 'images/cluster70.png', width: 70, height: 70, anchor: [35, 0], textColor: '#A0A0A0', textSize: 10 },
				{ url: 'images/cluster80.png', width: 80, height: 80, anchor: [40, 0], textColor: '#A0A0A0', textSize: 10 }
			],
			clusterGridSize: 70,
			clusterMaxZoom: 17,
			clusterMinSize: 7
		},
		/*** map & marker initialisation ***/
		init: function () {
			var self = this;	// this is Map, not Aporee!!!
			var mapTypes = [
				"OSM",
				google.maps.MapTypeId.SATELLITE,
				google.maps.MapTypeId.HYBRID,
				google.maps.MapTypeId.ROADMAP,
				google.maps.MapTypeId.TERRAIN,
			];
			var mapType = google.maps.MapTypeId.SATELLITE;
			var mapOptions = {
				zoom: this.Settings.defaultZoom,
				center: this.Settings.defaultPoint,
				mapTypeId: mapType,
				mapTypeControl: true,
				mapTypeControlOptions: {
					mapTypeIds: mapTypes,
					// style: google.maps.MapTypeControlStyle.DROPDOWN_MENU,
					// style: google.maps.MapTypeControlStyle.HORIZONTAL_BAR,
					// style: google.maps.MapTypeControlStyle.DEFAULT,
					position: google.maps.ControlPosition.TOP_RIGHT
				},
				scaleControl: true,
				backgroundColor: '#202020'
			};
			this.map = new google.maps.Map(document.getElementById("map"), mapOptions);
			// osm test
			this.map.mapTypes.set('OSM',this.osmMapType);

			// hidden input marker
			this.inputMarker = new google.maps.Marker({
				position: this.Settings.defaultPoint,
				map: this.map,
				icon: this.Settings.inputMarkerImg,
				flat: true,
				clickable: false,
				visible: false
			});
			this.hotMarker = new google.maps.Marker({
				position: this.Settings.defaultPoint,
				map: this.map,
				icon: this.Settings.mapsActiveMarkerImg,
				flat: true,
				clickable: false,
				visible: false,
				optimized: false	// for animated gif!
				// hack api v3
				// draggable: true
			});
			// click on map
			google.maps.event.addListener(this.map, 'click', function(e) {
				// alert("currently disabled, we're moving, back soon, stay tuned...");
				// return;
				// EJS.config({ cache: false });
				self.inputMarker.setVisible(true);
				self.inputMarker.setPosition(e.latLng);
				var lat = e.latLng.lat();
				var lng = e.latLng.lng();
				var html = new EJS({ url: 'templ/inputInfoWindow.ejs' }).render({ lat: lat, lng: lng });
				self.infoWindow.setContent(html);
				self.infoWindow.open(self.map, self.inputMarker);
				// Aporee.showUploadForm(lat, lng);

			});
			// limit zoom level
			google.maps.event.addListener(this.map, 'zoom_changed', function() {
              			if (self.map.getZoom() < 3) {
                  			self.map.setZoom(3);
              			}
          		});


			// disable drag
			this.map.disableKeyDragZoom();
		},
		/*** generic marker creation, needed only for loc 0 ***/
		createMarker: function(i) {
			var self = this;
			var locid = parseInt(self.locationsArray[i].locid);
			var lat = parseFloat(self.locationsArray[i].lat);
			var lng = parseFloat(self.locationsArray[i].lng);
			var zoom = parseInt(self.locationsArray[i].zoom);
			var title = self.locationsArray[i].title;
			var point = new google.maps.LatLng(lat,lng);

			var Marker = new google.maps.Marker({
				position: point,
				map: null,
				icon: self.Settings.mapsMarkerImg,
				title: title,
				locid: locid,
				zoom: zoom,
				flat: true
			});
			/*** marker click ***/
			google.maps.event.addListener(Marker, 'click', function() {
				self.openLocation(this.locid, true);
			});
			// add to cluster
			self.markersArray[i] = Marker;
			self.markersIndexArray[i] = locid;
			self.markerCluster.addMarker(Marker);
		},
		/***
			async request data for all locations:
			- load json from server
			- create marker for latest location and push it to cluster
			- open it or process query
			- create rest of marker and push them to cluster
			watch out for race conditions! see panTo...
		***/
		requestLocations: function () {
			var self = this;
			// eye candy while loading....
			Aporee.om = new OverlayMessage( document.getElementById( 'map' ) );
			Aporee.om.Set( 'loading places...' );
			// create empty Clusterer first
			self.markerCluster = new MarkerClusterer(self.map, self.markersArray, {
				gridSize: self.Settings.clusterGridSize,
				maxZoom: self.Settings.clusterMaxZoom,
				minimumClusterSize: self.Settings.clusterMinSize,
				styles: self.Settings.clusterStyles
			});
			// load all data in locationsArray
			var data = {};
			data.args = [];
			data.func_name = 'getAllLocations';
			try {
				x_change(data, function(result) {
					// result json
					self.locationsArray = result.ret;
					// always create latest marker individually, should be on top of locationsArray
					self.createMarker(0);
					// open / play latest, or process query if any
					Aporee.initLocationQuery();
					// load rest of markers in pseudo background job
					self.requestMarkers(self.locationsArray);
				});
			} catch (e) {
				alert(e.message);
			}
		},
		/*** load marker in chunks to prevent js timeout, process cluster when finished ***/
		requestMarkers: function (locations) {
			var self = this;
			var chunk = 500;
			var l = locations.length;
			// 0 already loaded !
			var i = 1;
			function doParts() {
				var cnt = chunk, locid, lat, lng, zoom, title, point;
				while (cnt-- && i < l) {
					locid = parseInt(locations[i].locid);
					lat = parseFloat(locations[i].lat);
					lng = parseFloat(locations[i].lng);
					zoom = parseInt(locations[i].zoom);
					title = locations[i].title;
					point = new google.maps.LatLng(lat,lng);

					var Marker = new google.maps.Marker({
						position: point,
						map: null,
						icon: self.Settings.mapsMarkerImg,
						title: title,
						locid: locid,
						zoom: zoom,
						flat: true
					});
					/*** marker click ***/
					google.maps.event.addListener(Marker, 'click', function() {
						self.openLocation(this.locid, true);
					});
					// keep array of markers
					self.markersArray[i] = Marker;
					// keep parallel locids, same index for markes and related locids
					self.markersIndexArray[i] = locid;
					// not i++ !
					++i;
				}
				// recurse until all markers are created, then push them to cluster
				if (i < l) {
					setTimeout(doParts, 1);
				} else {
					// clear eye candy
					Aporee.om.Clear();
					self.markerCluster.addMarkers(self.markersArray);
				}
			}
			doParts();
		},
		/*** all things that should happen on marker click ***/

		/***
			open location by locid: load playlist, opens infowindow when info=true, set hotmarker
			problem: locid / marker may not exist when this is called

		***/
		openLocation: function (locid, info) {

			// panTo has to return a marker! but what if not? only needed when info = true
			var marker = this.panTo(locid);

			// console.log("openLocation: locid: " + locid);
			if (info) {
				this.openInfoWindow(marker);
			}
			Aporee.Player.loadPlaylist([locid]);	// array as arg
		},
		/*** opens infoWindow when clicked on detail in soundInfo (more...), see EJS template  ***/
		openDetail: function(locid) {
			// loc already open?
			if (this.infoWindow.getMap() && this.infoWindow.locid == locid) {
				return;
			}
			var idx = this.markersIndexArray.indexOf(locid);
			var marker = this.markersArray[idx];
			this.openInfoWindow(marker);
		},
		/*** infowindow, styles in css/page.css, html from templ/ ***/
		openInfoWindow: function(marker) {
			var self = this;
			var locid = marker.locid;
			var data = {
				args: [ locid ],
				func_name: 'getLocationInfo'
			};
			try {
				x_change(data, function(result) {
					// EJS.config({ cache: false });
					var html = new EJS({ url: 'templ/infoWindow.ejs' }).render({ locid: locid, sounds: result.ret });
					self.infoWindow.locid = locid;	// remember locid, see openDetail
					self.infoWindow.setContent(html);
					self.infoWindow.open(self.map, marker);
				});
			} catch (e) {
				alert(e.message);
			}
		},
		/***
			move & zoom map to locid, used e.g. on playlist change
			panTo is called by openLocation, and desperately needs to return a marker,
			but markers may not be loaded yet because of requestMarkers is still running
			-> check if marker exists in markersIndexArray, if, process it, if not, recurse...
		***/
		panTo: function(locid) {
			var self = this;
			// check how often we've run
			self.panTo.run = 0;
			function checkMarker() {
				var idx = self.markersIndexArray.indexOf(locid);
				// console.log("panTo: locid: " + locid + " idx: " + idx + " # of runs: " + self.panTo.run);
				if ( -1 === idx) {
					// stop recursion after 30 loops, i.e. locid doesn't exist
					if (self.panTo.run > 30) {
						return false;
					}
					self.panTo.run++;
					// not found, wait a second and try again...
					setTimeout(checkMarker, 1000);
				} else {
					var marker = self.markersArray[idx];
					var zoom = marker.zoom;
					var position = marker.position;
					self.map.setZoom(zoom);
					self.map.setCenter(position);
					self.hotMarker.setPosition(position);
					self.hotMarker.setVisible(true);
					return marker;
				}
			}
			// this must return a marker!
			return checkMarker();
		},
		/*** simple google places search ***/
		searchGoogle: function() {
			var t = new EJS({ url: 'templ/searchGoogle.ejs'}).update('text');
			var el = document.getElementById("searchGoogle");
			if(el && el.value != "") {
				if(!this.geocoder) {
					this.geocoder = new google.maps.Geocoder();
				}
				self = this;
				this.geocoder.geocode( { 'address': el.value }, function(results, status) {
					if (status == google.maps.GeocoderStatus.OK) {
						self.map.setMapTypeId(google.maps.MapTypeId.HYBRID);
						self.map.fitBounds(results[0].geometry.viewport);
						self.map.setCenter(results[0].geometry.location);
						t({ address: results[0].formatted_address });
					} else {
						t({ address: Strings.searchGoogleNoResult });
					}
				});
			} else {
				t({ address: Strings.searchGoogleInput });
			}
		}
	},
	/*** Aporee functions ***/

	/*** load places in sidebar/text div ***/
	getNewLocations: function(p) {
		var self = this;
		var str = Strings.newLocationsDay;
		switch (p) {
			case 'd':
				str = Strings.newLocationsDay;
			break;
			case 'w':
				str = Strings.newLocationsWeek;
			break;
			case 'm':
				str = Strings.newLocationsMonth;
			break;
		}
		var data = {};
		data.args = [ p ];	// d(ay), w(eek), m(onth)
		data.func_name = 'getNewLocations';
		try {
			x_change(data, function(result) {
				var locations = result.ret;
				if (locations.length > 0) {
					self.locationsList = locations;
					var myData = { label: str, locations: locations, play: Strings.playList };
					// update div text
					// EJS.config({ cache: false });
					new EJS({ url: 'templ/newLocations.ejs' }).update('text', myData);
				} else {
					document.getElementById('text').innerHTML = '';
				}
			});
		} catch (e) {
			alert(e.message);
		}
	},
	/*** open newest location, or process query_string, if any ***/
	initLocationQuery: function() {
		// console.log(this.query);
		// e.g. link to places: /?loc=1234
		if(this.query.loc) {
			// set map type to query or sat
			var m = (this.query.m && (/^(OSM|hybrid|satellite|roadmap|terrain)$/i).exec(this.query.m))
				? this.query.m == 'osm' ? 'OSM' : this.query.m
				: 'satellite';
			this.Map.map.setMapTypeId(m);
			this.Map.openLocation(parseInt(this.query.loc), false);
		} else if (this.query.clat && this.query.clng) {	// area center, zoom, maptype set
			var c = new google.maps.LatLng(parseFloat(this.query.clat), parseFloat(this.query.clng));
			var z = parseInt(this.query.z);
			// match maptype
			var m = (this.query.m && (/^(OSM|hybrid|satellite|roadmap|terrain)$/i).exec(this.query.m))
				? this.query.m == 'osm' ? 'OSM' : this.query.m
				: 'satellite';
			this.Map.map.setMapTypeId(m);
			this.Map.map.setCenter(c);
			this.Map.map.setZoom(z);
		} else {	// no query, load latest, should be at pos 0!
		 	this.Map.openLocation(this.Map.markersIndexArray[0], false);
		}
	},
	/*** text search ***/
	searchLocation: function() {
		var self = this;
		var t = new EJS({ url: 'templ/searchLocation.ejs'}).update('text');
		var el = document.getElementById("searchLocation");
		if(el && el.value != "") { 	// form empty
			var data = {};
			data.args = [ el.value ];	// search str
			data.func_name = 'searchLocation';
			try {
				x_change(data, function(result) {
					var locations = result.ret;
					if(locations.length > 0) {
						self.locationsList = locations;
						t({ label: Strings.searchLocationResult, locations: locations, play: Strings.playList });
					} else {
						t({ label: Strings.searchLocationNoResult, locations: [], play: '' });
					}
				});
			} catch (e) {
				alert(e.message);
			}
		} else {
			t({ label: '', locations: [], play: '' });
		}
	},
	searchUser: function(uid, artist) {
		if(uid != '') {
			var data = {};
			data.args = [ uid ];	// search str
			data.func_name = 'searchUser';
			try {
				x_change(data, function(result) {
					var locations = result.ret;
					var label = (locations.length > 0) ? Strings.searchUserResult : Strings.searchUserNoResult;
					var myData = {
						artistId: uid,
						artist: artist,
						label: label,
						locations: locations,
						play: Strings.playList
					};
					// update div text
					new EJS({url: 'templ/searchUser.ejs'}).update('text', myData)
				});
			} catch (e) {
				alert(e.message);
			}
		}
	},
	/*** creates an array of locid arrays e.g. from search results, for playlist
	     functions are responsible for populating locationsList
	***/
	playResult: function() {
		var list = [];
		for(var i=0, j=this.locationsList.length; i<j; i++) {

			list.push(this.locationsList[i].locid);
		}
		this.Player.loadPlaylist(list);
	},
	/*** some statistics fun ***/
	getStatistics: function() {
		var data = {};
		data.args = [];
		data.func_name = 'getStatistics';
		try {
			x_change(data, function(result) {
				// EJS.config({ cache: false });
				new EJS({url: 'templ/statistics.ejs'}).update('text', result.ret)
			});
		} catch (e) {
			alert(e.message);
		}
	},
	/*** just for fun ***/
	getCenter: function() {
		var self = this;
		var data = {};
		data.args = [];
		data.func_name = 'getCenter';
		try {
			x_change(data, function(result) {
				var clat = result.ret.lat;
				var clng = result.ret.lng;
				var c = new google.maps.LatLng(clat,clng);
				self.Map.inputMarker.setPosition(c);
				self.Map.inputMarker.setVisible(true);
				self.Map.map.setCenter(c);
				self.Map.map.setZoom(8);
			});
		} catch (e) {
			alert(e.message);
		}

	},
	/*** activated dragSelect ***/
	selectMap: function() {
		if(!this.Map.map.getDragZoomObject()) {
			var self = this;	// Aporee
			this.Map.map.enableKeyDragZoom({
				key: "shift",
				boxStyle: {
					border: "1px solid black",
					backgroundColor: "transparent",
					opacity: 1.0
				},
				veilStyle: {
					backgroundColor: "#000000",
					opacity: 0.5,
					cursor: "crosshair"
				}
			});
			// save points of dragged area
			this.Map.dragZoomObj = this.Map.map.getDragZoomObject();
			google.maps.event.addListener(this.Map.dragZoomObj, 'drag', function (startPt, endPt) {
				self.Map.dragStart = startPt;
				self.Map.dragStop = endPt;
			});
			// make screnshot on dragend
			google.maps.event.addListener(this.Map.dragZoomObj, 'dragend', Aporee.exportSelectedMap);
		}
		document.getElementById('text').innerHTML = Strings.selectMap;
	},
	/*** make "screenshot" for embedding, based on dragzoom ***/
	exportSelectedMap: function(e) {	// e: bound
		var width = Math.abs(Aporee.Map.dragStart.x - Aporee.Map.dragStop.x);
		var height = Math.abs(Aporee.Map.dragStart.y - Aporee.Map.dragStop.y);
		// min width = player + text, e.g. 250 + 100
		width = (width < 300) ? 300 : width;
		height = (height < 200) ? 200 : height + 50; // + player + info
		var zoom = Aporee.Map.map.getZoom();
		var map = Aporee.Map.map.getMapTypeId();
		var sw = e.getSouthWest();
		var ne = e.getNorthEast();
		var swlat = sw.lat().toFixed(6);
		var swlng = sw.lng().toFixed(6);
		var nelat = ne.lat().toFixed(6);
		var nelng = ne.lng().toFixed(6);
		var url = projectUrl + 'export/?swlat=' + swlat + '&swlng='+ swlng + '&nelat=' + nelat + '&nelng='+ nelng
			+ '&z=' + zoom + '&m=' + map + '&w=' + width + '&h=' + height;
		// var url = 'export/?' + e.toUrlValue() + ',' + zoom + ',' + width + ',' + height + ',' + map;
		// console.log('KeyDragZoom Bounds: ' + e.toUrlValue() + ' w/h: ' + width + '/' + height + ' url: ' + url);
		window.open(url, "export", "width=" + width + ", height=" + height + ", left=100, top=200, resizable=yes");
		// window.open(url, "export");
		// EJS.config({ cache: false });
		new EJS({url: 'templ/exportSelectedMap.ejs'}).update('text', { url: url, w: width, h: height });
		// document.getElementById('text').innerHTML = '';
	},
	/*** creates a link to the current map bounds ***/
	linkCurrentMap: function() {
		var address = 'radio aporee';
		// EJS.config({ cache: false });
		var t = new EJS({ url: 'templ/linkCurrentMap.ejs'}).update('text');
		var center = this.Map.map.getCenter();
		var clat = center.lat().toFixed(6);
		var clng = center.lng().toFixed(6);
		var zoom = this.Map.map.getZoom();
		var bounds = this.Map.map.getBounds();
		var map = Aporee.Map.map.getMapTypeId();
		var url = projectUrl + '?clat=' + clat + '&clng='+ clng + '&z=' + zoom + '&m=' + map;
		if(!this.Map.geocoder) {
			this.Map.geocoder = new google.maps.Geocoder();
		}
		this.Map.geocoder.geocode( { 'bounds': bounds }, function(results, status) {
			if (status == google.maps.GeocoderStatus.OK) {
				address = results[0].formatted_address;
			}
			t({ address: address, url: url });
		});
	},
	/*** creates a link to a specific loc ***/
	// problem: old export urls use /maps/export?lat=... style -> todo
	linkExportLocation: function(locid) {
		if(! locid) return;
		// EJS.config({cache: false});
		var t = new EJS({ url: 'templ/linkExportLocation.ejs'}).update('text');
		var w = 400;
		var h = 300;
		var idx = this.Map.markersIndexArray.indexOf(locid);
		var marker = this.Map.markersArray[idx];
		// http://aporee.org/maps/export/?lat=-34.4522007788657&lng=-58.5549348592758&zoom=18&type=s&locid=3943&title=supermercado%20galaxia
		var lat = marker.position.lat().toFixed(6);
		var lng = marker.position.lng().toFixed(6);
		var zoom = marker.zoom;
		var title = marker.title;
		var map = Aporee.Map.map.getMapTypeId();
		// var zoom = marker.zoom;
		// todo... projectAlias = /maps, projectUrl = /maps/work
		var linkUrl = projectAlias + '?loc=' + locid + '&m=' + map;
		// var exportUrl = projectUrl + 'export/?loc=' + locid + '&m=' + map;
		var exportUrl =  projectAlias + 'export/?lat=' + lat + '&lng=' + lng + '&zoom=' + zoom + '&type=s&locid=' + locid + '&title=' + encodeURIComponent(title);
		// console.log(linkUrl, exportUrl);
		window.open(exportUrl, "export", "width=" + w + ", height=" + h + ", left=100, top=200, resizable=yes");
		t({ w: w, h: h, linkUrl: linkUrl, exportUrl: exportUrl, title: title });
	},
	/*** open geo-multiplayer focussed around current area **/
	openMultiplayer: function() {
		var center = this.Map.map.getCenter();
		var clat = center.lat().toFixed(6);
		var clng = center.lng().toFixed(6);
		var zoom = this.Map.map.getZoom();
		var map = Aporee.Map.map.getMapTypeId();
		var url = projectUrl + 'play.php?clat=' + clat + '&clng='+ clng + '&z=' + zoom + '&m=' + map;
		window.open(url, "multiplayer");
	},
	/*** send comment to sound id ***/
	mailTo: function(sndid, send) {
		if(send) {
			// read form
			var comment = document.commentForm.commentText.value;
			var from = document.commentForm.commentFrom.value;
			if(comment != '') {
				var data = {};
				data.args = [ sndid, from, comment ];
				data.func_name = 'mailTo';
				try {
					x_change(data, function(result) {});
				} catch (e) {
					alert(e.message);
				}
			}
			document.getElementById(sndid).innerHTML = '';
		} else {
			// div name is sndid, needs to be a string type
			new EJS({ url: 'templ/mailTo.ejs' }).update(sndid.toString(), { sndid: sndid });
		}
	},
	/*** upload: upload form (in templ/) goes to upload.php with target "uploadframe"
		status from this and upload.php (onload) goes to uploadstatus div. todo:
		html5 upload, auto detection of browser, etc. ***/

	/*** show upload form for new place ***/
	showNewUploadForm: function(lat, lng) {
		// show divs for upload form
		this.Utils.toggle('uploadscreen');
		this.Utils.toggle('uploadcontent');
		this.Map.infoWindow.close();

		// EJS.config({ cache: false });
		var t = new EJS({ url: 'templ/newUploadForm.ejs'}).update('uploadcontent');
		// remember session?
		var email = '';
		var licence = '';
		// prefill placename?
		var address = '';
		var zoom = this.Map.map.getZoom();
		var bounds = this.Map.map.getBounds();
		if(!this.Map.geocoder) {
			this.Map.geocoder = new google.maps.Geocoder();
		}
		// async!!!
		this.Map.geocoder.geocode( { 'bounds': bounds }, function(results, status) {
			if (status == google.maps.GeocoderStatus.OK) {
				address = results[0].formatted_address;
			}
			// keep lat/lng precision
			t({ lat: lat, lng: lng, zoom: zoom, address: address, email: email, licence: licence });
		});
	},
	/*** show upload form for existing place ***/
	showToUploadForm: function(locid) {
		// show divs for upload form
		this.Utils.toggle('uploadscreen');
		this.Utils.toggle('uploadcontent');
		// this.Map.infoWindow.close();
		var idx = this.Map.markersIndexArray.indexOf(locid);
		var marker = this.Map.markersArray[idx];
		var title = marker.title;
		// needed for maps_calls, this has to change
		var lat = marker.getPosition().lat();
		var lng = marker.getPosition().lng();
		// EJS.config({ cache: false });
		var t = new EJS({ url: 'templ/toUploadForm.ejs'}).update('uploadcontent');
		// session
		var email = '';
		var licence = '';
		t({ lat: lat.toFixed(8), lng: lng.toFixed(8), locid: locid, email: email, licence: licence, title: title });
	},
	/*** validates & submits upload form, set status ***/
	upload: function(form) {
		// basic validation
		var error = '';
		var p = form.uploadPlaceTitle.value;
		var r = form.uploadRecTitle.value;
		var e = form.uploadEmail.value;
		var u = form.uploadUrl.value;
		var t = parseInt(form.timestamp.value);
		var h = parseInt(form.hour.value);
		var m = parseInt(form.minute.value);
		var now = new Date(t);
		var hour = now.getHours();
		var min = now.getMinutes();

		if(p == '' || p.length < 3) error += Strings.uploadValidatePlaceTitle;
		if(r == '' || r.length < 3) error += Strings.uploadValidateRecTitle;
		if(!(/\w{1,}[@][\w\-]{1,}([.]([\w\-]{1,})){1,3}$/.test(e))) error += Strings.uploadValidateEmail;
		if(u && !(/^(http|https|ftp):\/\/(([A-Z0-9][A-Z0-9_-]*)(\.[A-Z0-9][A-Z0-9_-]*)+)(:(\d+))?\/?/i.test(u))) error += Strings.uploadValidateUrl;
		if(h == hour && m == min) error += Strings.uploadValidateTime;
		if(error) {
			alert(Strings.uploadValidateError + error);
		} else {
			form.submit();
			document.getElementById('uploadstatus').innerHTML = Strings.uploadUploading; // animated
			// hide divs for upload form
			this.Utils.toggle('uploadscreen');
			this.Utils.toggle('uploadcontent');
		}
		return false;
	},
	/*** executed by upload.php after uploading or error, updates status ***/
	uploadDone: function(result) {
		var r = '';
		var e = document.getElementById('uploadstatus');
		switch (result) {
			case '0':	// ok
				r = Strings.uploadSuccess;
			break;
			case '1':	// max size (ini) exceeded
				r = Strings.uploadError1;
			break;
			case '2':	// max. size
				r = Strings.uploadError2;
			break;
			case '3':	// partial upload occured
				r = Strings.uploadError3;
			break;
			case '4':	// no file selected
				r = Strings.uploadError4;
			break;
			case '5':	// cannot access remote sound file
				r = Strings.uploadError5;
			break;
			case '6':	// cannot download remote sound file
				r = Strings.uploadError6;
			break;
			case '7':	// wrong or no extension
				r = Strings.uploadError7;
			break;
			case '8':	// wrong specs
				r = Strings.uploadError8;
			break;
			default:
				r = Strings.uploadErrorOther;

		}
		setTimeout(function(){ e.innerHTML = '' }, 60000);
		e.innerHTML = r;
		alert(r);
	},
	/*** add this sound to users favourites. id: locid ***/
	addFavourite: function (locid, sndid) {
		if(parseInt(locid) > 0 && parseInt(sndid) > 0 ) {
			var data = {};
			data.args = [ locid, sndid ];
			data.func_name = 'addFavourite';
			try {
				x_change(data, function(result) {
					var r = result.ret;
					if(!r){
						alert(Strings.favouritesError);
					} else if (r < 0) {
						alert(Strings.favouritesExists);
					} else if(r > 0) {
						alert(Strings.favouritesOK);
					}
				});
			} catch (e) {
				alert(e.message);
			}
		}
	},
	/*** get list of favourite locations for this month ***/
	getFavourites: function() {
		var self = this;
		var data = {};
		data.func_name = 'getFavourites';
		try {
			x_change(data, function(result) {
				var locations = result.ret;
				if (locations.length > 0) {
					self.locationsList = locations;
					var data = { locations: locations, play: Strings.playList };
					// EJS.config({ cache: false });
					new EJS({ url: 'templ/Favourites.ejs' }).update('text', data);
				} else {
					document.getElementById('text').innerHTML = '';
				}
			});
		} catch (e) {
			alert(e.message);
		}
	},
	/*** aporee cookies for language & other setings ***/
	switchLang: function () {	// aporee, lang
		var date = new Date();
		date.setTime(date.getTime()+(365*24*60*60*1000));
		var cookie = 'aporee_maps_lang=' + Strings.cookie + '; expires=' + date.toGMTString() + '; path=/maps';
		document.cookie = cookie;
		location.reload();
	},
	/*** showstart. watch out, latest loc arrives async! see Map.requestMarkers(), this.initLocationQuery() ***/
	init: function() {
		this.Map.init();					// load map
		this.Map.requestLocations();				// load markers
		this.Player.create('player');				// load player
		this.getNewLocations('d');				// show 24h news
		// EJS.config({ cache: false });
		new EJS({url: 'templ/menu.ejs'}).update('menu', {});	// make dropdown menu
	}
};
</script>
</head>
<body onload="Aporee.init()">
	<iframe id="uploadframe" name="uploadframe" src="" width="1" height="1" scrolling="no" frameborder="0"></iframe>
	<div id="map" style="width:100%; height:100%"></div>
	<div id="uploadscreen" style="display: none;" />
	<div id="uploadcontent" style="display: none;" />
</body>
</html>
